# Lab0: networking warmup
## 使用telnet命令和netcat命令(client and server)
- client
```
telnet cs144.keithw.org http
GET /hello HTTP/1.1
Host: cs1444.keithw.org
Connection: close


// 访问http:cs144.keithw.org/hello
```
- server
```
netcat -v -l -p 9090

//new terminal
telnet localhost 9090

// Connection from localhost #### received!
// everything typed in either window will appear in the other window. 
```
## 编写webget封装HTTP请求
- 利用封装好的TCPSocket类，进行socket的连接和发送。之后循环读取socket返回的内容。最后关闭socket。
## 实现bytestream
### 过程
先阅读给的TCPSocket类和Address类，查看这个类的接口。

### 功能
- 分为发送端和接收端。
- 发送端可以结束发送，输出端在读完字节流之后将会到达“EOF”的状态并且不再读入数据。
- 进行流量控制，限制内存消耗。有一个capacity属性，当writer写满后就不能继续写了，需要reader读出一些数据才能继续写。
- byte stream在单线程上使用。
- writer
```
void push( std::string data ); // Push data to stream, but only as much as available capacity allows.
void close();// Signal that the stream has reached its ending. Nothing more will be written.
void set_error(); // Signal that the stream suffered an error.
bool is_closed() const;// Has the stream been closed?
uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now?
uint64_t bytes_pushed() const;// Total number of bytes cumulatively pushed to the stream
```
- reader
```
std::string_view peek() const; // Peek at the next bytes in the buffer
void pop( uint64_t len );// Remove `len` bytes from the buffer
bool is_finished() const; // Is the stream finished (closed and fully popped)?
bool has_error() const;// Has the stream had an error?
uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped)
```

### 优化后
- 使用string_view, std::move进行优化。
- 使用std::deque<std::string>作为data队列，使用std::deque<std::string_view>作为view队列。
# Lab1: stitching substrings into a byte stream
## 实现Reassembler

# Lab2: the TCP receiver
## 序列号在64位和32位之间进行转换
## 实现TCPReceiver

# Lab3: the TCP sender
## 实现TCPSender

# Lab4: down the stack
## 实现NetworkInterface

# Lab5: building an IP router
## 实现Router
