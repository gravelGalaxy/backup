# 基本要求
- 可以使用给出的类库，对于需要实现的类，可以自己添加数据成员和方法，但是不能改变共有的接口。
# Lab0: networking warmup
## 使用telnet命令和netcat命令(client and server)
- client
```
telnet cs144.keithw.org http
GET /hello HTTP/1.1
Host: cs1444.keithw.org
Connection: close


// 访问http:cs144.keithw.org/hello
```
- server
```
netcat -v -l -p 9090

//new terminal
telnet localhost 9090

// Connection from localhost #### received!
// everything typed in either window will appear in the other window. 
```
## 编写webget封装HTTP请求
- 利用封装好的TCPSocket类，进行socket的连接和发送。之后循环读取socket返回的内容。最后关闭socket。
## 实现bytestream
### 过程
1. 先阅读给的TCPSocket类和Address类，查看这个类的接口。

### 功能
- 分为发送端和接收端。
- 发送端可以结束发送，输出端在读完字节流之后将会到达“EOF”的状态并且不再读入数据。
- 进行流量控制，限制内存消耗。有一个capacity属性，当writer写满后就不能继续写了，需要reader读出一些数据才能继续写。
- byte stream在单线程上使用。
- writer
```
void push( std::string data ); // Push data to stream, but only as much as available capacity allows.
void close();// Signal that the stream has reached its ending. Nothing more will be written.
void set_error(); // Signal that the stream suffered an error.
bool is_closed() const;// Has the stream been closed?
uint64_t available_capacity() const; // How many bytes can be pushed to the stream right now?
uint64_t bytes_pushed() const;// Total number of bytes cumulatively pushed to the stream
```
- reader
```
std::string_view peek() const; // Peek at the next bytes in the buffer
void pop( uint64_t len );// Remove `len` bytes from the buffer
bool is_finished() const; // Is the stream finished (closed and fully popped)?
bool has_error() const;// Has the stream had an error?
uint64_t bytes_buffered() const; // Number of bytes currently buffered (pushed and not popped)
```

### 优化后
- 使用string_view, std::move进行优化。
- 使用std::deque<std::string>作为data队列，使用std::deque<std::string_view>作为view队列。
0. push时可以通过将字符串转化成右值减少拷贝。
1. string_view在peek时使用，即返回队列的首个元素，避免无意义的拷贝。
2. 在pop时需要比较所pop的长度与string_view队列中的首个元素的长度,如果string_view队列首个元素更长，需要remove_prefix;否则直接将string_view队列首个元素pop掉。
# Lab1: stitching substrings into a byte stream
## 实现Reassembler
- 作用：因为TCP可靠传输使用序列号来处理丢失、乱序、重复的数据。所以这里用Reassembler来对字符串进行整流。
- 要求：Reassembler和ByteStream保存的最大字符数量之和是确定的。一旦插入了ByteStream想要的字符序列对应的字符，Reassembler就应该将这一段连续的字符串输出到ByteStream中。如果没有不是ByteSream想要的字符序列，就保存在Reassembler里。超过容量的字符直接舍弃。
```
void insert(uint64_t first_index, std::string data, bool is_last_subsring, Writer& output);
uint64_t bytes_pending() const;
```
- 给字符串的序列号、字符串、是否是最后一个字符串和用于输出的对象
### 自己实现的思路
1. 思路1
- 最开始就像尽快能通过测试，直接使用unordered_map，用字符作为值，字符的索引作为键保存起来，然后每次插入直接遍历所给的字符串，将哈希表中没有的字符保存起来。最后查一下我想要的那个值有没有在哈希表里就行了，有的话就通过循环的方式把连续的字符提取出来然后输出即可。
- 但是这种方法的效率很低，虽然通过了，但是在做后面的实验的时候就会导致超时。
2. 思路2
- 怎样降低时间复杂度和空间复杂度。考虑使用循环队列，长度是整流器的容量 + 1。（也是一个哈希？）

### 别人的思路
- 先预处理字符串，然后在给定的字符串的末尾序列号之前，遍历buffer中的每一个字符串，找到空闲的部分并对应插入。
- 通过移动语义较少了不必要的拷贝。

# Lab2: the TCP receiver
## 注意
- 流量控制：接受方能够接受的索引范围，由ack和window_size决定。
## 64位索引和32位序列号之间进行转换
- 使用64位作为索引几乎可以说永远不会overflow。Transmitting at 100 gigabits/sec, it would take almost 50 years to reach 264 bytes. By contrast, it takes only a third of a second to reach 232 bytes.
- 但是在TCP头部中只能存储32为的序列号，所以需要在64位索引和32位序列号之间进行转换。

- 需要处理32位序列号回绕问题。
- TCP序列号从一个随机值开始ISN。
- SYN、FIN都占用一个序列号。

- 因为64位索引和32位序列号之间的转换可能会产生bug,所以将32位序列号封装了起来，从系统层面减少bug的出现。
```
static Wrap32 Wrap32::wrap( uint64 t n, Wrap32 zero point )
// Convert absolute seqno → seqno. Given an absolute sequence number (n) and an Initial Sequence Number (zero point), produce the (relative) sequence number for n.
uint64 t unwrap( Wrap32 zero point, uint64 t checkpoint ) const // 通过给ISN和checkpoint,找到最接近的64位索引。

```
## 实现TCPReceiver
- 给发送方返回acknumber和接受窗口大小，接受窗口大小有一个最大限度，要和可用容量相比较才能确定。
- 记录对方的ISN来对64位索引和32位序列号进行转换。
- 将收到的bytes通过Reassembler传递到inbound中。


- 需要考虑清楚ack的计算
```
class TCPReceiver
{
public:
/* The TCPReceiver receives TCPSenderMessages, inserting their payload
* into the Reassemble at the correct stream index. */
void receive( TCPSenderMessage message, Reassembler& reassembler, Writer& inbound_stream );
/* The TCPReceiver sends TCPReceiverMessages back to the TCPSender. */
TCPReceiverMessage send( const Writer& inbound_stream ) const;
};
```

# Lab3: the TCP sender
- 确保TCPReceiver对每一个字节至少接受一次。
- 将outbound中的byte stream转换成数据报
- 从ByteStream中读取字符串然后转化成TCP数据报发送出去。
## 超时重传
- retransmission timeout(RTO):在重新发送一个数据包前应等待的时间。
- 每次发送数据包时，如果没有启动计时则启动它，当发送的所有数据包都被确认后，关闭计时器。

- 在超时时，需要重发没被确认的最早的数据包, 记录重传的次数，将RTO的值翻倍。
## 实现TCPSender
- 给一个ByteStream,将它分成多个数据包，然后发送给接收方。如果没有及时确认，重新发送数据包。
### 要求
- 记录接收方的窗口大小
- 创建TCP数据报，尽可能的占满接受方窗口。
- 保留已经发送但是还没有被确认的数据包。
- 如果超时需要重新发送数据包。
### 实现
- 利用queued_segments保存等待发送的数据包， outstanding_segents保存已经发送的数据包。
```
void push(Reader& outbound_stream);
```
- 只有能读取数据并且窗口有空间，就尽可能产生TCP数据包。而且TCP数据包中的数据要尽可能大，但是最大不超过1452byte。
- 当接收方窗口大小是0的时候，发送方要发送一个只带序列号的数据包，一旦接收方能够接收新的数据了，就会通知发送方自己的窗口大小。

- 利用while循环，当记录下来的已发送的数据总长比窗口大小小时，就创建一个TCP数据包。而当创建的TCP数据包长度是0时说明没有数据可以读了，就停止。

```
std::optional<TCPSenderMessage> maybe_send();
```
- TCPSender真正的发送一个TCPSenderMessage
``` 
void receive(const TCPReceiverMessage msg);
```
- 接收ack和窗口大小。
- 要根据ackno移除已经确认的数据包。

- 利用循环把记录下来的已发送并得到确认的数据包pop掉。
```
void tick(const size_t ms_since_last_tick);
```
- 告诉定时器自从上次这个方法被调用，到现在经过了多长时间爱你。
```
void send_empty_message();
```
- 发送一个只带序列号的数据包。


# Lab4: down the stack
## 实现NetworkInterface : ARP
```
void NetworkInterface::send_datagram( const InternetDatagram& dgram, const Address& next_hop);
```
- 将datagram转换成Ethernet帧人啊后发送到下一跳。
- 如果已经知道目的因特网地址，直接发送。
- 如果不知道到，广播一个ARP请求，并把IP datagram放到队列中以在得到ARP相应后能够被发送。
- 如果networkInterface已经在5秒内发送了一个相同IP地址的ARP请求，在这段时间内就不需要再次发送，避免网络被ARP请求大量占用。
```
optional<InternetDatagram> NetworkInterface::recv_frame( const EthernetFrame &frame);
```
- 接受网络上发来的Ethernet帧。
- 忽略任何目的地不是本机的因特网地址或者广播地址的帧。
- 根据帧的类型（IPv4或ARP），对应的将负载分析出来。如果是InternetDatagram,返回；如果是ARP，需要将IP地址和Ethernet地址之间的映射关系记录30s，如果是ARP请求，还要返回一个ARP响应。
```
std::optional<EthernetFrame> maybe_send();
```
```
void NetworkInterface::tick(cosnt size_t ms_since_last_tick);
```
- 删除已经超时的IP-Ethernet映射。

# Lab5: building an IP router
## 实现Router
- 根据路由表传递它得到的数据报。
1. 发送到什么interface,
2. 下一跳的IP地址。

```
void add_route(uint32_t route_prefix, uint8_t prefix_length, optional<Address> next_hop, size_t interface_num);
```
- 向路由表中添加路由。
```
void route();
```
- 最长前缀匹配。
- 如果route没有匹配到，或者TTL减到了0,丢弃datagram
## 实现
- 使用std::map<uint8_t, std::unordered_map<uint32_t, std::pair<std::optional<Address>, size_t>>, std::greater<>> rtable_{};作为路由表
- std::map是排过序的容器，这里用的是降序，把前缀最长的排在前面。
- 前缀长度-> (前缀 - > {地址，接口})

- 注意将header的ttl减1后需要重新计算checksum

### route
1. 遍历所有接口
2. 当接口有数据报传递时进行循环处理，否则退出循环。
